

# 如何解决顺序消息？

> 顺序消息只能保证局部顺序，并且大多数业务场景也仅仅需要局部顺序。

**世界上解决一个计算机问题最简单的方法：“恰好”不需要解决它！——沈询**

因此，对于RocketMQ来说，MQ本身(Broker)不提供顺序消息的保证,而是通过生产者和消费者的控制，实现顺序消息。



# 如何解决重复消息？

> **世界上解决一个计算机问题最简单的方法：“恰好”不需要解决它！——沈询**

还是这个理论，RocketMQ本身不提供重复消息处理，而是将此任务交给了消费端。

1. 消费端处理消息的业务逻辑保持幂等性
2. 保证每条消息都有唯一编号且保证消息处理成功与去重表的日志同时出现

# 为何不用ZooKeeper？

ZooKeeper的功能很强大，包括自动Master选举等，RocketMQ的架构设计决定了它不需要进行Master选举， 用不到这些复杂的功能，只需要一个轻量级的元数据服务器就足够了。值得注意的是，NameServer并没有提供类似Zookeeper的watcher机制， 而是采用了每30s心跳机制。

# DMA

​		DMA(Direct Memory Access,直接存储器访问)。在DMA出现之前，CPU与外设之间的数据传送方式有**程序传送方式**、**中断传送方式**。CPU是通过系统总线与其他部件连接并进行数据传输。



> 参考资料：https://blog.csdn.net/zhejfl/article/details/82555634

# MMAP

mmap(memory map)是一种内存映射文件的方法，即将一个文件或者其它对象映射到进程的地址空间，实现文件磁盘地址和进程虚拟地址空间中一段虚拟地址的一一对映关系。实现这样的映射关系后，进程就可以采用指针的方式读写操作这一段内存，而系统会自动回写脏页面到对应的文件磁盘上，即完成了对文件的操作而不必再调用read,write等系统调用函数。相反，内核空间对这段区域的修改也直接反映用户空间，从而可以实现不同进程间的文件共享。如下图所示：

![img](https://images0.cnblogs.com/blog2015/571793/201507/200501092691998.png)

# ByteBuffer之DirectoryBuffer

# ByteBuffer之MappedByteBuffer

