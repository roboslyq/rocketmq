# RocketMQ之长轮询

# Push or Pull

MQ中消息传递的模式有Push和Pull两种。
 Pull: 消费者主动从Broker拉取
 Push: Broker主动推送给消费者

在RocketMQ虽然有对于消费者的`DefaultMQPullConsumer`和`DefaultMQPushConsumer`两个Api可供选择，但是底层其实都使用`PullAPIWrapper`这个类进行消息拉取，也就是说，RocketMQ使用的消费传递模型是Pull模型。

**为什么pull**

push的最大好处的实时，但是也有以下缺点

1. 在Broker端需要维护Consumer的状态，不利于Broker去支持大量的Consumer的场景
2. Consumer的消费速度是不一致的，由Broker进行推送难以处理不同的Consumer的状况
3. Broker难以处理Consumer无法消费消息的情况（Broker无法确定Consumer的故障是短暂的还是永久的）
4. 大量的推送消息会加重Consumer的负载或者冲垮Consumer

pull很好的解决了上面的问题，但是也丢失了实时性。为了保证实时，我们可以把拉取消息的间隔设置的短一点，但这也带来了一个另外一个问题，在没有消息的时候时候会有大量pull请求，为了解决这个问题，就采用了本文讲解的长轮询技术。

# 什么是长轮询

轮询是以固定间隔请求服务器，它不在乎这次请求是否能拉取到消息。而长轮询，它请求的服务端，会等待一会儿时间，然后将等待时间内的消息返回。如果超时了，那么也返回空。有效的避免了无效的请求。

但是对于每次都能拉取到消息的情况下，长轮询也就退化成了轮询。

**轮询：**

　　**1：大量耗费服务器内存和宽带资源，因为不停的请求服务器，很多时候 并没有新的数据更新，因此绝大部分请求都是无效请求**

　　**2：数据不一定是实时更新，要看设定的请求间隔，基本会有延迟。**

**长轮询：**

　　**1：解决了轮询的两个大问题，数据实时更新；**

　　**2：唯一的缺点是服务器在挂起的时候比较耗内存；**

# PullAPIWrapper





# 参考资料 https://www.jianshu.com/p/c717cb26752e